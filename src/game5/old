import React, { useEffect, useState, createRef, useRef } from "react";

const words = ["du", "ipsum", "dolor"];

const PositionWords = () => {
  const lineStyle = {
    display: "flex",
    marginLeft: 150,
  };

  const wordStyle = {
    backgroundColor: "#5AC8F5",
    fontSize: 18,
    color: "#fff",
    padding: "7.5px 10px",
    borderRadius: 7.5,
    cursor: "pointer",
    position: "relative",
    top: 0,
    left: 0,
  };

  const wordRefs = words.map(() => createRef(null));

  const handleMove = (initEvent, index) => {
    const element = initEvent.target;

    element.setAttribute("left", element.getBoundingClientRect().left);
    element.setAttribute("right", element.getBoundingClientRect().right);

    const elementX = element.getBoundingClientRect().left;
    const elementY = element.getBoundingClientRect().top;

    const cursorX = initEvent.clientX - elementX;
    const cursorY = initEvent.clientY - elementY;

    const styleX = parseFloat(element.style.left);
    const styleY = parseFloat(element.style.top);

    element.style.zIndex = "1000";

    let mouseX = initEvent.clientX;
    let direction;

    let positions = [[], [], []];

    for (let i = 0; i < wordRefs.length; i++) {
      positions[i][0] = wordRefs[i].current.getBoundingClientRect().left;
      positions[i][1] = wordRefs[i].current.getBoundingClientRect().right;
    }

    console.log(positions);

    const moveElement = (moveEvent) => {
      if (mouseX < moveEvent.clientX) direction = "right";
      else if (mouseX > moveEvent.clientX) direction = "left";

      mouseX = moveEvent.clientX;

      element.style.left =
        moveEvent.clientX - elementX - cursorX + styleX + "px";
      element.style.top =
        moveEvent.clientY - elementY - cursorY + styleY + "px";

      for (let i = 0; i < wordRefs.length; i++) {
        if (i === index) continue;

        if (direction === "right") {
          if (
            moveEvent.clientX >=
              wordRefs[i].current.getBoundingClientRect().right -
                wordRefs[i].current.getBoundingClientRect().width / 2 &&
            moveEvent.clientX <=
              wordRefs[i].current.getBoundingClientRect().right
          ) {
            const oldPosition = parseFloat(element.getAttribute("left"));
            const newPosition =
              oldPosition + wordRefs[i].current.getBoundingClientRect().width;

            wordRefs[i].current.style.transition = "0s linear";
            wordRefs[i].current.style.left =
              oldPosition -
              wordRefs[i].current.getBoundingClientRect().left +
              parseFloat(wordRefs[i].current.style.left) +
              "px";

            element.setAttribute("left", newPosition);
            element.setAttribute(
              "right",
              newPosition + element.getBoundingClientRect().width
            );

            console.log(element);
          }
        } else if (direction === "left") {
          if (i === index) continue;

          if (
            moveEvent.clientX >=
              wordRefs[i].current.getBoundingClientRect().left &&
            moveEvent.clientX <=
              wordRefs[i].current.getBoundingClientRect().left +
                wordRefs[i].current.getBoundingClientRect().width / 2
          ) {
            const oldPosition = parseFloat(element.getAttribute("right"));
            const newPosition =
              oldPosition - wordRefs[i].current.getBoundingClientRect().width;

            wordRefs[i].current.style.transition = "0s linear";
            wordRefs[i].current.style.left =
              oldPosition -
              wordRefs[i].current.getBoundingClientRect().width -
              wordRefs[i].current.getBoundingClientRect().left +
              parseFloat(wordRefs[i].current.style.left) +
              "px";

            element.setAttribute("right", newPosition);
            element.setAttribute(
              "left",
              newPosition - element.getBoundingClientRect().width
            );

            console.log(element);
          }
        }
      }
    };

    const endMove = (endEvent) => {
      element.style.zIndex = "1";

      if (direction === "right") {
        element.style.left =
          parseFloat(element.getAttribute("left")) - elementX + styleX + "px";
      } else if (direction === "left") {
        element.style.left =
          parseFloat(element.getAttribute("right")) -
          element.getBoundingClientRect().width -
          elementX +
          styleX +
          "px";
      }
      element.style.top = 0 + "px";

      document.removeEventListener("mousemove", moveElement);
      document.removeEventListener("mouseup", endMove);
    };

    document.addEventListener("mousemove", moveElement);
    document.addEventListener("mouseup", endMove);
  };

  return (
    <div className="line" style={lineStyle}>
      {words.map((item, index) => (
        <div
          className="word"
          ref={wordRefs[index]}
          onMouseDown={(e) => handleMove(e, index)}
          style={wordStyle}
        >
          {item}
        </div>
      ))}
    </div>
  );
};

export default PositionWords;
